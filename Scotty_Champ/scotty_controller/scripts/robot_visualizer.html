<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scotty Robot State Visualizer</title>
    <script src="https://unpkg.com/three@0.146.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.146.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/three@0.146.0/examples/js/loaders/STLLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/roslib@1.3.0/build/roslib.min.js"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        
        #canvas-container {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        
        #status {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 100;
        }
        
        #loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            font-size: 24px;
            z-index: 1000;
        }
        
        #help-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 100;
        }
        
        #help-toggle {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            font-weight: bold;
            cursor: pointer;
        }
        
        #help-content {
            display: none;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 5px;
            margin-top: 10px;
            max-width: 400px;
            font-size: 14px;
        }
        
        #help-content h3, #help-content h4 {
            margin-top: 10px;
            margin-bottom: 5px;
        }
        
        #help-content code {
            background-color: rgba(255, 255, 255, 0.1);
            padding: 2px 4px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="status">Connecting to ROS...</div>
    <div id="loading">Loading robot model...</div>

    <div id="help-panel">
        <button id="help-toggle">?</button>
        <div id="help-content">
            <h3>Scotty Robot Visualizer</h3>
            <p>This visualizer connects to ROS and displays the Scotty robot model with real-time joint updates.</p>
            
            <h4>URL Parameters:</h4>
            <ul>
                <li><code>rosbridge_url</code> - WebSocket URL for ROS bridge (default: ws://localhost:9090)</li>
                <li><code>urdf_path</code> - Path to the URDF file</li>
                <li><code>ros_package_path</code> - Base path to ROS packages</li>
                <li><code>joint_states_topic</code> - ROS topic for joint states (default: /joint_states)</li>
            </ul>
            
            <h4>Example:</h4>
            <code>?rosbridge_url=ws://192.168.1.100:9090&urdf_path=../scotty_description/urdf/scotty_description.urdf</code>
        </div>
    </div>

    <script>
        // Global variables
        let scene, camera, renderer, controls;
        let robotGroup = new THREE.Group();
        let ros;
        let jointStateSubscriber;
        
        // Store joint objects for animation
        const jointMap = {};
        
        // Configuration options
        const config = {
            // ROS Bridge WebSocket URL
            rosbridge_url: 'ws://localhost:9090',
            
            // ROS topic for joint states
            joint_states_topic: '/joint_states',
            
            // Path to the URDF file
            urdf_path: '../../scotty_description/urdf/scotty_description.urdf',
            
            // Base path to the ROS packages
            ros_package_path: '../',
            
            // Map of ROS package names to their relative paths
            packages: {
                'scotty_description': '../scotty_description'
            }
        };
        
        // Materials
        const materials = {
            body: new THREE.MeshStandardMaterial({
                color: 0x607d8b,
                metalness: 0.7,
                roughness: 0.5
            }),
            link: new THREE.MeshStandardMaterial({
                color: 0xb0bec5,
                metalness: 0.5,
                roughness: 0.5
            }),
            joint: new THREE.MeshStandardMaterial({
                color: 0xf57c00, 
                metalness: 0.5,
                roughness: 0.7
            }),
            end: new THREE.MeshStandardMaterial({
                color: 0x4caf50,
                metalness: 0.2,
                roughness: 0.8
            })
        };
        
        // Parse URL parameters to override configuration
        function parseUrlParams() {
            const urlParams = new URLSearchParams(window.location.search);
            
            // Override rosbridge URL if provided
            if (urlParams.has('rosbridge_url')) {
                config.rosbridge_url = urlParams.get('rosbridge_url');
            }
            
            // Override URDF path if provided
            if (urlParams.has('urdf_path')) {
                config.urdf_path = urlParams.get('urdf_path');
            }
            
            // Override ROS package path if provided
            if (urlParams.has('ros_package_path')) {
                config.ros_package_path = urlParams.get('ros_package_path');
            }
            
            // Override joint states topic if provided
            if (urlParams.has('joint_states_topic')) {
                config.joint_states_topic = urlParams.get('joint_states_topic');
            }
            
            console.log('Configuration with URL overrides:', config);
        }
        
        // Setup Three.js scene
        function initScene() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);
            scene.add(robotGroup);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0.5, 2.5);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // Add orbit controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.25;
            controls.target.set(0, 0.3, 0);
            
            // Add lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
            mainLight.position.set(1, 2, 1);
            mainLight.castShadow = true;
            scene.add(mainLight);
            
            const backLight = new THREE.DirectionalLight(0xffffff, 0.3);
            backLight.position.set(-1, 0.5, -1);
            scene.add(backLight);
            
            // Event listeners
            window.addEventListener('resize', onWindowResize);
            
            // Start animation loop
            animate();
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        // Resize handler
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Parse URDF
        function parseURDF(text) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(text, "text/xml");
            
            // Extract robot info
            const robotEl = xmlDoc.querySelector('robot');
            const robotName = robotEl.getAttribute('name');
            
            // Parse links
            const links = {};
            xmlDoc.querySelectorAll('link').forEach(linkEl => {
                const linkName = linkEl.getAttribute('name');
                links[linkName] = { name: linkName };
                
                // Extract visual elements
                const visualEl = linkEl.querySelector('visual');
                if (visualEl) {
                    const geometryEl = visualEl.querySelector('geometry');
                    if (geometryEl) {
                        const meshEl = geometryEl.querySelector('mesh');
                        if (meshEl) {
                            links[linkName].mesh = meshEl.getAttribute('filename');
                        }
                    }
                    
                    // Extract origin if any
                    const originEl = visualEl.querySelector('origin');
                    if (originEl) {
                        const xyz = originEl.getAttribute('xyz');
                        const rpy = originEl.getAttribute('rpy');
                        
                        links[linkName].origin = { x: 0, y: 0, z: 0 };
                        links[linkName].rpy = { roll: 0, pitch: 0, yaw: 0 };
                        
                        if (xyz) {
                            const xyzParts = xyz.split(' ').map(parseFloat);
                            links[linkName].origin.x = xyzParts[0] || 0;
                            links[linkName].origin.y = xyzParts[1] || 0;
                            links[linkName].origin.z = xyzParts[2] || 0;
                        }
                        
                        if (rpy) {
                            const rpyParts = rpy.split(' ').map(parseFloat);
                            links[linkName].rpy.roll = rpyParts[0] || 0;
                            links[linkName].rpy.pitch = rpyParts[1] || 0;
                            links[linkName].rpy.yaw = rpyParts[2] || 0;
                        }
                    }
                }
            });
            
            // Parse joints
            const joints = {};
            xmlDoc.querySelectorAll('joint').forEach(jointEl => {
                const jointName = jointEl.getAttribute('name');
                const jointType = jointEl.getAttribute('type');
                
                const parentEl = jointEl.querySelector('parent');
                const childEl = jointEl.querySelector('child');
                
                if (parentEl && childEl) {
                    joints[jointName] = {
                        name: jointName,
                        type: jointType,
                        parent: parentEl.getAttribute('link'),
                        child: childEl.getAttribute('link')
                    };
                    
                    // Extract origin if any
                    const originEl = jointEl.querySelector('origin');
                    if (originEl) {
                        const xyz = originEl.getAttribute('xyz');
                        const rpy = originEl.getAttribute('rpy');
                        
                        joints[jointName].origin = { x: 0, y: 0, z: 0 };
                        joints[jointName].rpy = { roll: 0, pitch: 0, yaw: 0 };
                        
                        if (xyz) {
                            const xyzParts = xyz.split(' ').map(parseFloat);
                            joints[jointName].origin.x = xyzParts[0] || 0;
                            joints[jointName].origin.y = xyzParts[1] || 0;
                            joints[jointName].origin.z = xyzParts[2] || 0;
                        }
                        
                        if (rpy) {
                            const rpyParts = rpy.split(' ').map(parseFloat);
                            joints[jointName].rpy.roll = rpyParts[0] || 0;
                            joints[jointName].rpy.pitch = rpyParts[1] || 0;
                            joints[jointName].rpy.yaw = rpyParts[2] || 0;
                        }
                    }
                    
                    // Extract axis if any
                    const axisEl = jointEl.querySelector('axis');
                    if (axisEl) {
                        const xyzAttr = axisEl.getAttribute('xyz');
                        if (xyzAttr) {
                            const xyzParts = xyzAttr.split(' ').map(parseFloat);
                            joints[jointName].axis = {
                                x: xyzParts[0] || 0,
                                y: xyzParts[1] || 0,
                                z: xyzParts[2] || 0
                            };
                        }
                    }
                    
                    // Extract limits if any
                    const limitEl = jointEl.querySelector('limit');
                    if (limitEl) {
                        joints[jointName].limits = {
                            lower: parseFloat(limitEl.getAttribute('lower') || 0),
                            upper: parseFloat(limitEl.getAttribute('upper') || 0)
                        };
                    }
                }
            });
            
            return {
                name: robotName,
                links: links,
                joints: joints
            };
        }
        
        // Load STL mesh
        function loadSTLMesh(url, material, origin, rpy, scale, callback) {
            return new Promise((resolve, reject) => {
                const loader = new THREE.STLLoader();
                loader.load(
                    url,
                    (geometry) => {
                        // Create mesh with provided material
                        const mesh = new THREE.Mesh(geometry, material);
                        
                        // Apply transformations if provided
                        if (origin) {
                            mesh.position.set(origin.x || 0, origin.y || 0, origin.z || 0);
                        }
                        
                        if (rpy) {
                            mesh.rotation.set(rpy.roll || 0, rpy.pitch || 0, rpy.yaw || 0, 'ZYX');
                        }
                        
                        if (scale) {
                            mesh.scale.set(scale.x || 1, scale.y || 1, scale.z || 1);
                        }
                        
                        // Enable shadows
                        mesh.castShadow = true;
                        mesh.receiveShadow = true;
                        
                        if (callback) callback(mesh);
                        resolve(mesh);
                    },
                    (xhr) => {
                        // Progress, if needed
                    },
                    (error) => {
                        console.error('Error loading STL:', error);
                        reject(error);
                    }
                );
            });
        }
        
        // Load robot from URDF
        async function loadRobotFromURDF(urdf, baseUrl) {
            console.log("Loading robot:", urdf.name);
            
            // Base URL for relative paths
            const basePath = baseUrl.substring(0, baseUrl.lastIndexOf('/') + 1);
            
            // Load all links with meshes
            const linkPromises = [];
            const linkObjects = {};
            
            // First phase: load all meshes
            for (const linkName in urdf.links) {
                const link = urdf.links[linkName];
                
                if (link.mesh) {
                    let meshPath = link.mesh;
                    
                    // Handle package:// URIs (common in ROS)
                    if (meshPath.startsWith("package://")) {
                        // Extract the package path
                        const packagePath = meshPath.substring(10);
                        const slashIndex = packagePath.indexOf('/');
                        if (slashIndex !== -1) {
                            const packageName = packagePath.substring(0, slashIndex);
                            const restPath = packagePath.substring(slashIndex + 1);
                            
                            // Use configuration to map package paths
                            if (config.packages[packageName]) {
                                meshPath = config.ros_package_path + config.packages[packageName] + '/' + restPath;
                            } else {
                                // Default fallback for unknown packages
                                meshPath = config.ros_package_path + packageName + '/' + restPath;
                            }
                            
                            console.log(`Resolved package path ${link.mesh} to ${meshPath}`);
                        }
                    }
                    
                    console.log(`Loading mesh for ${linkName}: ${meshPath}`);
                    
                    let loadPromise;
                    if (meshPath.toLowerCase().endsWith('.stl') || meshPath.toLowerCase().endsWith('.STL')) {
                        // Determine material type (links, joints, end effectors)
                        let material = materials.link;
                        if (linkName.toLowerCase().includes('body') || linkName.toLowerCase().includes('base')) {
                            material = materials.body;
                        } else if (linkName.toLowerCase().includes('joint') || 
                                  linkName.toLowerCase().includes('hip') || 
                                  linkName.toLowerCase().includes('knee') || 
                                  linkName.toLowerCase().includes('ankle') ||
                                  linkName.toLowerCase().includes('abad')) {
                            material = materials.joint;
                        } else if (linkName.toLowerCase().includes('hand') || 
                                  linkName.toLowerCase().includes('foot') || 
                                  linkName.toLowerCase().includes('gripper') || 
                                  linkName.toLowerCase().includes('end')) {
                            material = materials.end;
                        }
                        
                        loadPromise = loadSTLMesh(
                            meshPath,
                            material,
                            link.origin,
                            link.rpy,
                            null,
                            (mesh) => {
                                mesh.name = linkName;
                                // Create a group for this link
                                const linkGroup = new THREE.Group();
                                linkGroup.name = linkName + "_group";
                                linkGroup.add(mesh);
                                linkObjects[linkName] = linkGroup;
                            }
                        );
                    } else {
                        console.warn(`Unsupported mesh type for ${linkName}: ${meshPath}`);
                        const linkGroup = new THREE.Group();
                        linkGroup.name = linkName + "_group";
                        linkObjects[linkName] = linkGroup;
                        loadPromise = Promise.resolve();
                    }
                    
                    linkPromises.push(loadPromise);
                } else {
                    // Create an empty group for links without meshes
                    const linkGroup = new THREE.Group();
                    linkGroup.name = linkName + "_group";
                    linkObjects[linkName] = linkGroup;
                }
            }
            
            try {
                await Promise.all(linkPromises);
                console.log("All meshes loaded");
                
                // Second phase: Organize links by joint hierarchy
                // Find the root link (usually base_link)
                let rootLinkName = "base_link"; // Default
                
                // Add all links that aren't children in any joint
                const childLinks = new Set();
                for (const jointName in urdf.joints) {
                    const joint = urdf.joints[jointName];
                    childLinks.add(joint.child);
                }
                
                // Find links that are not children
                for (const linkName in urdf.links) {
                    if (!childLinks.has(linkName)) {
                        rootLinkName = linkName;
                        break;
                    }
                }
                
                console.log(`Root link: ${rootLinkName}`);
                
                // Start with the root link
                if (linkObjects[rootLinkName]) {
                    robotGroup.add(linkObjects[rootLinkName]);
                }
                
                // Function to recursively add children links
                function addChildLinks(parentLinkName) {
                    for (const jointName in urdf.joints) {
                        const joint = urdf.joints[jointName];
                        
                        if (joint.parent === parentLinkName) {
                            const childLinkName = joint.child;
                            const childLink = linkObjects[childLinkName];
                            
                            if (childLink) {
                                const parentLink = linkObjects[parentLinkName];
                                if (parentLink) {
                                    parentLink.add(childLink);
                                    console.log(`Added ${childLinkName} to ${parentLinkName}`);
                                    
                                    // Apply joint transformations if available
                                    if (joint.origin) {
                                        childLink.position.set(
                                            joint.origin.x || 0,
                                            joint.origin.y || 0,
                                            joint.origin.z || 0
                                        );
                                    }

                                    if (joint.rpy) {
                                        childLink.rotation.set(
                                            joint.rpy.roll || 0,
                                            joint.rpy.pitch || 0,
                                            joint.rpy.yaw || 0,
                                            'ZYX'
                                        );
                                    }
                                    
                                    // Store joint for animation
                                    if (joint.type !== 'fixed') {
                                        jointMap[jointName] = {
                                            object: childLink,
                                            type: joint.type,
                                            axis: joint.axis,
                                            originalRotation: childLink.rotation.clone(),
                                            originalPosition: childLink.position.clone()
                                        };
                                    }
                                    
                                    // Recursively add children of this link
                                    addChildLinks(childLinkName);
                                }
                            }
                        }
                    }
                }
                
                // Start building the hierarchy
                addChildLinks(rootLinkName);
                
                // If the recursive approach fails, add all remaining links directly to robot group
                for (const linkName in linkObjects) {
                    const link = linkObjects[linkName];
                    if (link.parent === null) {
                        robotGroup.add(link);
                    }
                }
                
                // Position and orient robot properly
                centerAndOrientRobot();
                
                console.log("Robot hierarchy built");
                document.getElementById('loading').style.display = 'none';
                
            } catch (error) {
                console.error("Error loading meshes:", error);
                document.getElementById('status').textContent = 'Error loading robot model: ' + error.message;
                throw error;
            }
        }
        
        // Center and orient robot properly
        function centerAndOrientRobot() {
            if (robotGroup.children.length === 0) return;
            
            // Reset any previous transformations
            robotGroup.position.set(0, 0, 0);
            robotGroup.rotation.set(0, 0, 0);
            robotGroup.scale.set(1, 1, 1);
            
            // Calculate bounding box
            const boundingBox = new THREE.Box3().setFromObject(robotGroup);
            const center = boundingBox.getCenter(new THREE.Vector3());
            const size = boundingBox.getSize(new THREE.Vector3());
            
            // Center the robot - ensure it's standing on the origin
            robotGroup.position.set(-center.x, -boundingBox.min.y, -center.z);
            
            // Scale the robot to a reasonable size
            const maxDim = Math.max(size.x, size.y, size.z);
            if (maxDim > 0) {
                const scale = 1.0 / maxDim;
                robotGroup.scale.set(scale, scale, scale);
            }
            
            // Rotate to make the robot stand properly
            robotGroup.rotation.set(-Math.PI/2, 0, Math.PI);
        }
        
        // Connect to ROS
        function connectToROS() {
            // Set ROS connection using config
            ros = new ROSLIB.Ros({
                url: config.rosbridge_url
            });
            
            ros.on('connection', function() {
                console.log('Connected to ROS bridge.');
                document.getElementById('status').textContent = 'Connected to ROS';
                setupJointStateSubscriber();
            });
            
            ros.on('error', function(error) {
                console.error('Error connecting to ROS bridge:', error);
                document.getElementById('status').textContent = 'Error connecting to ROS: ' + error;
            });
            
            ros.on('close', function() {
                console.log('Connection to ROS bridge closed.');
                document.getElementById('status').textContent = 'Disconnected from ROS';
                
                // Try to reconnect after a delay
                setTimeout(function() {
                    connectToROS();
                }, 5000);
            });
        }
        
        // Setup joint state subscriber
        function setupJointStateSubscriber() {
            // Subscribe to joint_states topic from config
            jointStateSubscriber = new ROSLIB.Topic({
                ros: ros,
                name: config.joint_states_topic,
                messageType: 'sensor_msgs/JointState'
            });
            
            jointStateSubscriber.subscribe(function(message) {
                updateJointPositions(message);
            });
            
            console.log('Subscribed to /joint_states topic');
        }
        
        // Update joint positions based on received message
        function updateJointPositions(jointStateMsg) {
            const names = jointStateMsg.name;
            const positions = jointStateMsg.position;
            
            for (let i = 0; i < names.length; i++) {
                const jointName = names[i];
                const position = positions[i];
                
                if (jointMap[jointName]) {
                    const joint = jointMap[jointName];
                    
                    if (joint.type === 'revolute' || joint.type === 'continuous') {
                        // For revolute joints, we rotate around the specified axis
                        const axis = joint.axis;
                        const rotationAxis = new THREE.Vector3(axis.x, axis.y, axis.z);
                        
                        // Reset to original rotation
                        joint.object.rotation.copy(joint.originalRotation);
                        
                        // Apply additional rotation for the joint movement
                        // This approach is simplified; for complex robots you might need quaternions
                        if (Math.abs(axis.x) > 0.5) {
                            joint.object.rotateX(position);
                        } else if (Math.abs(axis.y) > 0.5) {
                            joint.object.rotateY(position);
                        } else if (Math.abs(axis.z) > 0.5) {
                            joint.object.rotateZ(position);
                        }
                    } else if (joint.type === 'prismatic') {
                        // For prismatic joints, we translate along the specified axis
                        const axis = joint.axis;
                        
                        // Reset to original position
                        joint.object.position.copy(joint.originalPosition);
                        
                        // Apply translation
                        joint.object.position.x += axis.x * position;
                        joint.object.position.y += axis.y * position;
                        joint.object.position.z += axis.z * position;
                    }
                }
            }
            
            // Update status with some joint info
            const statusText = `Connected to ROS: ${names.length} joints updated`;
            document.getElementById('status').textContent = statusText;
        }
        
        // Initialize the application
        async function init() {
            // Parse URL parameters to override config
            parseUrlParams();
            
            // Initialize the scene
            initScene();
            
            try {
                // Load URDF model using the path from config
                const urdfPath = config.urdf_path;
                
                const response = await fetch(urdfPath);
                if (!response.ok) {
                    throw new Error(`Failed to fetch URDF: ${response.status} ${response.statusText}`);
                }
                
                const urdfText = await response.text();
                const urdf = parseURDF(urdfText);
                await loadRobotFromURDF(urdf, urdfPath);
                
                // After model is loaded, connect to ROS
                connectToROS();
            } catch (error) {
                console.error('Error initializing:', error);
                document.getElementById('status').textContent = 'Error: ' + error.message;
                document.getElementById('loading').style.display = 'none';
                
                // Add fallback - show error details and path troubleshooting tips
                const errorDetails = document.createElement('div');
                errorDetails.style.marginTop = '20px';
                errorDetails.innerHTML = `
                    <p>Troubleshooting tips:</p>
                    <ul>
                        <li>Check that the URDF file exists at: <code>${config.urdf_path}</code></li>
                        <li>Check that mesh files exist in the scotty_description package</li>
                        <li>Check browser console for detailed error messages</li>
                        <li>Try adding a ROS_PACKAGE_PATH parameter to specify alternate locations</li>
                    </ul>
                `;
                document.getElementById('loading').appendChild(errorDetails);
            }
            
            // Setup help panel toggle
            document.getElementById('help-toggle').addEventListener('click', function() {
                const helpContent = document.getElementById('help-content');
                helpContent.style.display = helpContent.style.display === 'block' ? 'none' : 'block';
            });
        }
        
        // Start the application when window loads
        window.addEventListener('load', init);
    </script>
</body>
</html> 